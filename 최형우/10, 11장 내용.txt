프로세스
1) 포그라운드 프로세스
2) 백그라운드 프로세스  : 중에서 사용자와 상호작용 안하는 서비스 존재


프로세스 제어 블록(PCB) : 프로세스 생성과 동시에 생성 & 종료와 동시에 폐기
	- 프로세스 ID (PID)
	- 레지스터 값
	- 프로세스 상태
	- CPU 스케줄링 정보
	- 메모리 관리 정보
	- 사용한 파일과 입출력장치 목록

문맥 : 프로세스가 전환될때, 사용하던 프로세스의 정보들을 백업해주는 역할



프로세스의 메모리 영역
1) 코드(텍스트) 영역 : 실행하는 코드 -> 쓰기 금지
2) 데이터 영역 : 전역변수같은 유지할 데이터 저장되는 공간. 따라서 크기 고정됨 -> 1,2번 영역은 정적 할당 영역. 3, 4번은 동적 할당 영역
3) 힙 영역 : 프로그래머가 직접 할당하는 공간. 반환 안 할 시 메모리 누수 발생
4) 스택 영역 : 데이터 일시 저장하는 공간. 매개변수나 지역변수 같은것들


프로세스 상태 다이어그램 : 생성 -> 준비 <-> 실행 -> 종료     -> 입출력 장치 사용시 처리속도 차이로 인해 대기 필요
						     ㄴ 대기 」


- 부모 프로세스는 fork를 통해 복사본을 만든 뒤 exec를 통해 새로은 프로그램으로 만들어 자식 프로세스를 생성



스레드 : 프로세스의 실행 흐름 단위. 멀티 스레드로 활용시, 힙이나 데이터같은 영역은 공용으로 쓰되, 스택이나 레지스터& 프로그램 카운터등을 따로 사용하기 때문에
	멀티프로세스에 비해 메모리 낭비가 적다. but 공용 부분에서 문제 발생 시 다같이 영향받는게 단점



입출력 집중 프로세스 : 입출력 작업이 많아서 CPU사용시간 low -> 자주 대기 상태
CPU 집중 프로세스 : CPU사용시간 high -> 자주 실행 상태

스케쥴링 큐 : 자원을 사용할 프로세스들을 큐에 넣어서 순서대로 관리
 - 준비 큐 : CPU 사용 대기
 - 대기 큐 : 입출력 장치 대기

선점형 스케쥴링 : 운영체제가 프로세스가 사용하는 자원 강제로 뺏기 가능. but 문맥 교환과정에서 오버헤드 발생 가능
비선점형 스케쥴링 : 반대로 오버헤드는 적지만, 무작정 프로세스가 끝나길 기다리는 수 밖에 없음



스케쥴링 알고리즘
1) 선입 선처리(FCFS) :  먼저 대기한 프로세스부터 처리
2) 최단 작업 우선(SJF) : 실행시간이 짧은 프로세스 부터
3) 라운드 로빈 : 정해진 타임 슬라이스 시간만큼 돌아가며 사용
4) 최소 잔여 시간 우선(SRT) : 최단작업+라운드 로빈 -> 타임 슬라이스만큼 돌아가며 쓰지만 짧은 프로세스부터
5) 우선순위 : 우선순위대로 처리. But 낮은 순위는 계속 연기되는 '기아'현상 발생. 따라서 에이징을 통해 대기한 프로세스의 순위를 점차 높혀줌
6) 다단계 큐 : 우선순위 별로 큐를 여려개 만들어서 사용. 각각 타임슬라이스나 스케쥴링 방식을 다르게 적용 가능
7) 다단계 피드백 큐 : 다단계 큐와 달리 프로세스들이 큐 사이를 이동 가능. 새로 준비상태 들어오면 가장 높은 우선순위 큐에 삽입해서 실행 안될 경우 점점 순위를 내리는
식으로 동작. 마찬가지로 에이징 기법도 적용해 낮은 순위에 있는 장기간 대기 프로세스들은 순위 높여줌.